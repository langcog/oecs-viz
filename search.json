[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "oecs-viz",
    "section": "",
    "text": "// load d3\nd3 = require(\"d3@7\")\n\n\n\n\n\n\n\n// d3 force graph function\n// modified from https://observablehq.com/@d3/force-directed-graph\n// Original copyright 2021-2024 Observable, Inc.\n// Released under the ISC license.\n\nfunction ForceGraph({\n  nodes, // an iterable of node objects (typically [{id}, …])\n  links // an iterable of link objects (typically [{source, target}, …])\n}, {\n  nodeId = d =&gt; d.id, // given d in nodes, returns a unique identifier (string)\n  nodeGroup, // given d in nodes, returns an (ordinal) value for color\n  nodeGroups, // an array of ordinal values representing the node groups\n  nodeTitle, // given d in nodes, a title string\n  nodeLink, // given d in nodes, returns a URL string\n  nodeFill = \"currentColor\", // node stroke fill (if not using a group color encoding)\n  nodeStroke = \"#fff\", // node stroke color\n  nodeStrokeWidth = 1.5, // node stroke width, in pixels\n  nodeStrokeOpacity = 1, // node stroke opacity\n  nodeRadius = 5, // node radius, in pixels\n  nodeStrength,\n  linkSource = ({source}) =&gt; source, // given d in links, returns a node identifier string\n  linkTarget = ({target}) =&gt; target, // given d in links, returns a node identifier string\n  linkStroke = \"#999\", // link stroke color\n  linkStrokeOpacity = 0.6, // link stroke opacity\n  linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels\n  linkStrokeLinecap = \"round\", // link stroke linecap\n  linkStrength,\n  repulsion,\n  colors = d3.schemeTableau10, // an array of color strings, for the node groups\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  invalidation // when this promise resolves, stop the simulation\n} = {}) {\n  // Compute values.\n  const N = d3.map(nodes, nodeId).map(intern);\n  const R = typeof nodeRadius !== \"function\" ? null : d3.map(nodes, nodeRadius);\n  const LS = d3.map(links, linkSource).map(intern);\n  const LT = d3.map(links, linkTarget).map(intern);\n  if (nodeTitle === undefined) nodeTitle = (_, i) =&gt; N[i];\n  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);\n  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);\n  const W = typeof linkStrokeWidth !== \"function\" ? null : d3.map(links, linkStrokeWidth);\n  const L = typeof linkStroke !== \"function\" ? null : d3.map(links, linkStroke);\n  const LU = nodeLink == null ? null : d3.map(nodes, nodeLink);\n\n  // Replace the input nodes and links with mutable objects for the simulation.\n  nodes = d3.map(nodes, (_, i) =&gt; ({id: N[i]}));\n  links = d3.map(links, (_, i) =&gt; ({source: LS[i], target: LT[i]}));\n\n  // Compute default domains.\n  if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);\n\n  // Construct the scales.\n  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);\n\n  // Construct the forces.\n  const forceNode = d3.forceManyBody().strength(repulsion);\n  const forceLink = d3.forceLink(links).id(({index: i}) =&gt; N[i]);\n  if (nodeStrength !== undefined) forceNode.strength(nodeStrength);\n  if (linkStrength !== undefined) forceLink.strength(linkStrength);\n\n  const simulation = d3.forceSimulation(nodes)\n      .force(\"link\", forceLink)\n      .force(\"charge\", forceNode)\n      //.force(\"center\",  d3.forceCenter())\n      .force(\"center\", d3.forceCenter(width / 2, height / 2))\n      //.force(\"collision\", d3.forceCollide().radius(d =&gt; d.collisionRadius || nodeRadius + 2))\n      .force(\"collision\", d3.forceCollide().radius(d =&gt; d.collisionRadius || nodeRadius + 2).iterations(3))\n      .alphaDecay(0.02) // Slower cooling for better settling\n      .velocityDecay(0.3) // Less velocity damping for more movement\n      .on(\"tick\", ticked);\n\n      \n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      //.attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n      .attr(\"viewBox\", [0, 0, width, height])\n      //.attr(\"preserveAspectRatio\", \"xMidYMin\")\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", typeof linkStroke !== \"function\" ? linkStroke : null)\n      .attr(\"stroke-opacity\", linkStrokeOpacity)\n      .attr(\"stroke-width\", typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : null)\n      .attr(\"stroke-linecap\", linkStrokeLinecap)\n    .selectAll(\"line\")\n    .data(links)\n    .join(\"line\");\n\n  const node = svg.append(\"g\")\n      .attr(\"fill\", nodeFill)\n      .attr(\"stroke\", nodeStroke)\n      .attr(\"stroke-opacity\", nodeStrokeOpacity)\n      .attr(\"stroke-width\", nodeStrokeWidth)\n    .selectAll(\"circle\")\n    .data(nodes)\n    .join(\"circle\")\n      .attr(\"r\", nodeRadius)\n      .style(\"cursor\", LU ? \"pointer\" : null)\n      .call(drag(simulation))\n      .on(\"click\", function(event, d) {\n        if (LU && LU[d.index]) {\n          window.open(LU[d.index], '_blank');\n        }\n      });\n      /*\n      .on(\"mouseover\", function(event, d) {\n        // Show corresponding label\n        label.filter((_, i) =&gt; i === d.index)\n          .transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n      })\n      .on(\"mouseout\", function(event, d) {\n        // Hide corresponding label\n        label.filter((_, i) =&gt; i === d.index)\n          .transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      });\n      */\n\n  const label = svg.append(\"g\")\n      .attr(\"font-size\", 12)\n      .attr(\"fill\", \"#333\")\n      .attr(\"text-anchor\", \"start\")\n    .selectAll(\"text\")\n    .data(nodes)\n    .join(\"text\")\n      .text(({index: i}) =&gt; T ? T[i] : N[i])\n      .attr(\"dx\", nodeRadius + 3) // offset from node center\n      .attr(\"dy\", \"0.35em\") // vertical centering\n      .style(\"cursor\", LU ? \"pointer\" : null)\n      //.style(\"opacity\", 0) // Hidden by default\n      //.style(\"pointer-events\", \"none\") // Don't interfere with mouse events\n      .call(drag(simulation))\n      .on(\"click\", function(event, d) {\n        if (LU && LU[d.index]) {\n          window.open(LU[d.index], '_blank');\n        }\n      });\n      \n  label.each(function(d) {\n    const bbox = this.getBBox();\n    const labelWidth = bbox.width;\n    const labelHeight = bbox.height;\n    // Extend collision radius to account for label\n    const baseRadius = R ? R[d.index] : nodeRadius;\n    //d.collisionRadius = baseRadius + 2;\n    //d.collisionRadius = Math.max(baseRadius + 2, (labelWidth + nodeRadius + 16) / 2);\n    d.collisionRadius = Math.max(baseRadius + 8, (labelWidth + nodeRadius * 2 + 12) / 2);\n  });\n      \n  if (W) link.attr(\"stroke-width\", ({index: i}) =&gt; W[i]);\n  if (L) link.attr(\"stroke\", ({index: i}) =&gt; L[i]);\n  if (G) node.attr(\"fill\", ({index: i}) =&gt; color(G[i]));\n  if (G) label.attr(\"fill\", ({index: i}) =&gt; color(G[i]));\n  if (R) node.attr(\"r\", ({index: i}) =&gt; R[i]);\n  if (T) node.append(\"title\").text(({index: i}) =&gt; T[i]);\n  if (invalidation != null) invalidation.then(() =&gt; simulation.stop());\n\n  function intern(value) {\n    return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n  }\n\n  function ticked() {\n    link\n      .attr(\"x1\", d =&gt; d.source.x)\n      .attr(\"y1\", d =&gt; d.source.y)\n      .attr(\"x2\", d =&gt; d.target.x)\n      .attr(\"y2\", d =&gt; d.target.y);\n\n     node\n      .attr(\"cx\", d =&gt; {\n        const radius = d.collisionRadius || (R ? R[d.index] : nodeRadius);\n        //return d.x = Math.max(radius - width/2, Math.min(width/2 - radius, d.x));\n        return d.x = Math.max(radius, Math.min(width - radius, d.x));\n      })\n      .attr(\"cy\", d =&gt; {\n        const radius = d.collisionRadius || (R ? R[d.index] : nodeRadius);\n        //return d.y = Math.max(radius - height/2, Math.min(height/2 - radius, d.y));\n        return d.y = Math.max(radius, Math.min(height - radius, d.y));\n      });\n      \n    label\n      .attr(\"x\", d =&gt; d.x)\n      .attr(\"y\", d =&gt; d.y);\n  }\n\n  function drag(simulation) {    \n    function dragstarted(event) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }\n    \n    function dragged(event) {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }\n    \n    function dragended(event) {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }\n    \n    return d3.drag()\n      .on(\"start\", dragstarted)\n      .on(\"drag\", dragged)\n      .on(\"end\", dragended);\n  }\n\n  return Object.assign(svg.node(), {scales: {color}});\n}\n\n\n\n\n\n\n\nnt = transpose(nodes)\nlt = transpose(links)\ntt = transpose(themes)\nct = transpose(clusters)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilter articles by…\n\nviewof theme = Inputs.select(d3.group(tt, d =&gt; d.theme), {\n  label: \"Theme\",\n  value: \"All\"\n})\n\n\n\n\n\n\n\nviewof group = Inputs.select(d3.group(ct, d =&gt; d.group), {\n  label: \"Network cluster\",\n  value: \"All\"\n})\n\n\n\n\n\n\n\n\nLink articles by…\n\nmetrics = new Map([[\"GloVe distance\", \"similarity\"], [\"Crosslink\", \"crosslink\"]])\nviewof metric = Inputs.select(metrics, {\n  label: \"Similarity metric\",\n  value: \"similarity\"\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInclude links that are either…\n\nviewof k = Inputs.range([0, 8], {\n  label: \"Each article's k closest neighbors or\",\n  step: 1,\n  value: 2,\n  disabled: metric !== \"similarity\"\n})\n\n\n\n\n\n\n\nviewof s = Inputs.range([0.7, 1], {\n  label: \"Edge weight at least\",\n  step: 0.01,\n  value: 0.92,\n  disabled: metric !== \"similarity\"\n})\n\n\n\n\n\n\n\n\n\nhtml`&lt;button class=\"btn btn-quarto btn-reset\" onclick=\"location.reload()\"&gt;Reset&lt;/button&gt;`\n\n\n\n\n\n\n\n\n\ntheme_ids = theme.map(d =&gt; d.id)\ngroup_ids = group.map(d =&gt; d.id)\n\n// filter links based on theme and group\nltg = lt.filter(d =&gt; theme_ids.includes(d.source))\n        .filter(d =&gt; theme_ids.includes(d.target))\n        .filter(d =&gt; group_ids.includes(d.source))\n        .filter(d =&gt; group_ids.includes(d.target))\n\nfunction filterEdges(lt, metric, k, s) {\n  if (metric === 'crosslink') {\n    // filter links based on presence of crosslink\n    return ltg.filter(d =&gt; d.crosslink === 1)\n               .map(d =&gt; ({ ...d, w: 1 }))\n    \n  } else if (metric === 'similarity') {\n    // filter links based on edge weight inputs (k and s)\n    const ltw = d3.groups(ltg, d =&gt; d.source) // group by source node\n      .flatMap(([source, values]) =&gt; // iterate over node's links\n        values\n          // sort link valued in descending order\n          .sort((a, b) =&gt; b.value - a.value)\n          // keep k highest values and any values of at least s\n          .filter((d, i) =&gt; i &lt; k || d.similarity &gt;= s)\n    )\n    \n    // renormalize edge weights\n    const vmin = Math.min(... ltw.map(d =&gt; d.similarity))\n    const ltw_min = ltw.map(d =&gt; ({ ...d, similarity_norm: d.similarity - vmin }))\n    const vmax = Math.max(... ltw_min.map(d =&gt; d.similarity_norm))\n    const ltw_norm = ltw_min.map(d =&gt; ({ ...d, similarity_norm: d.similarity_norm / vmax }))\n    \n    return ltw_norm.map(d =&gt; ({ ...d, w: d.similarity &gt;= s ? d.similarity_norm * 2 : 0.5 }))\n  }\n}\nltf = filterEdges(lt, metric, k, s)\n\n// filter nodes based on theme and group\n//ntf = nt.filter(d =&gt; theme_ids.includes(d.id))\n//        .filter(d =&gt; group_ids.includes(d.id))\n\n// filter nodes based on filtered links\nntf = nt.filter(d =&gt; ltf.map(d =&gt; d.source).includes(d.id) || ltf.map(d =&gt; d.target).includes(d.id))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroups = [...new Set(ct.map(d =&gt; d.group))]\nnodeGroups = [...groups.keys()].splice(1).map(d =&gt; d.toString())\n\nForceGraph({nodes: ntf, links: ltf}, {\n  nodeTitle: d =&gt; d.id,\n  nodeLink: d =&gt; `https://oecs.mit.edu/pub/${d.slug}`,\n  nodeGroup: d =&gt; d.group,\n  nodeGroups: nodeGroups,\n  colors: d3.schemeCategory10.slice(0, nodeGroups.length),\n  linkStrokeWidth: l =&gt; l.w,\n  repulsion: -100,\n  width: 1250,\n  height: 750\n})"
  }
]