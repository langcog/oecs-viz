[
  {
    "objectID": "observableGraph.html",
    "href": "observableGraph.html",
    "title": "oecs-viz",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n\n\n\n\n\n\n\n// lightly modified from:\n// https://observablehq.com/@d3/force-directed-graph\n// Copyright 2021-2024 Observable, Inc.\n// Released under the ISC license.\n\nfunction ForceGraph({\n  nodes, // an iterable of node objects (typically [{id}, …])\n  links // an iterable of link objects (typically [{source, target}, …])\n}, {\n  nodeId = d =&gt; d.id, // given d in nodes, returns a unique identifier (string)\n  nodeGroup, // given d in nodes, returns an (ordinal) value for color\n  nodeGroups, // an array of ordinal values representing the node groups\n  nodeTitle, // given d in nodes, a title string\n  nodeLink, // given d in nodes, returns a URL string\n  nodeFill = \"currentColor\", // node stroke fill (if not using a group color encoding)\n  nodeStroke = \"#fff\", // node stroke color\n  nodeStrokeWidth = 1.5, // node stroke width, in pixels\n  nodeStrokeOpacity = 1, // node stroke opacity\n  nodeRadius = 5, // node radius, in pixels\n  nodeStrength,\n  linkSource = ({source}) =&gt; source, // given d in links, returns a node identifier string\n  linkTarget = ({target}) =&gt; target, // given d in links, returns a node identifier string\n  linkStroke = \"#999\", // link stroke color\n  linkStrokeOpacity = 0.6, // link stroke opacity\n  linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels\n  linkStrokeLinecap = \"round\", // link stroke linecap\n  linkStrength,\n  repulsion,\n  colors = d3.schemeTableau10, // an array of color strings, for the node groups\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  invalidation // when this promise resolves, stop the simulation\n} = {}) {\n  // Compute values.\n  const N = d3.map(nodes, nodeId).map(intern);\n  const R = typeof nodeRadius !== \"function\" ? null : d3.map(nodes, nodeRadius);\n  const LS = d3.map(links, linkSource).map(intern);\n  const LT = d3.map(links, linkTarget).map(intern);\n  if (nodeTitle === undefined) nodeTitle = (_, i) =&gt; N[i];\n  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);\n  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);\n  const W = typeof linkStrokeWidth !== \"function\" ? null : d3.map(links, linkStrokeWidth);\n  const L = typeof linkStroke !== \"function\" ? null : d3.map(links, linkStroke);\n  const LU = nodeLink == null ? null : d3.map(nodes, nodeLink);\n\n  // Replace the input nodes and links with mutable objects for the simulation.\n  nodes = d3.map(nodes, (_, i) =&gt; ({id: N[i]}));\n  links = d3.map(links, (_, i) =&gt; ({source: LS[i], target: LT[i]}));\n\n  // Compute default domains.\n  if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);\n\n  // Construct the scales.\n  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);\n\n  // Construct the forces.\n  const forceNode = d3.forceManyBody().strength(repulsion);\n  const forceLink = d3.forceLink(links).id(({index: i}) =&gt; N[i]);\n  if (nodeStrength !== undefined) forceNode.strength(nodeStrength);\n  if (linkStrength !== undefined) forceLink.strength(linkStrength);\n\n  const simulation = d3.forceSimulation(nodes)\n      .force(\"link\", forceLink)\n      .force(\"charge\", forceNode)\n      .force(\"center\",  d3.forceCenter())\n      .force(\"collision\", d3.forceCollide().radius(d =&gt; d.collisionRadius || nodeRadius + 2))\n      //.force(\"collision\", d3.forceCollide().radius(nodeRadius + 2))\n      .on(\"tick\", ticked);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", typeof linkStroke !== \"function\" ? linkStroke : null)\n      .attr(\"stroke-opacity\", linkStrokeOpacity)\n      .attr(\"stroke-width\", typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : null)\n      .attr(\"stroke-linecap\", linkStrokeLinecap)\n    .selectAll(\"line\")\n    .data(links)\n    .join(\"line\");\n\n  const node = svg.append(\"g\")\n      .attr(\"fill\", nodeFill)\n      .attr(\"stroke\", nodeStroke)\n      .attr(\"stroke-opacity\", nodeStrokeOpacity)\n      .attr(\"stroke-width\", nodeStrokeWidth)\n    .selectAll(\"circle\")\n    .data(nodes)\n    .join(\"circle\")\n      .attr(\"r\", nodeRadius)\n      .style(\"cursor\", LU ? \"pointer\" : null)\n      .call(drag(simulation))\n      .on(\"click\", function(event, d) {\n        if (LU && LU[d.index]) {\n          window.open(LU[d.index], '_blank');\n        }\n      });\n      //.call(drag(simulation));\n\n  const label = svg.append(\"g\")\n      //.attr(\"font-family\", \"Arial, sans-serif\")\n      .attr(\"font-size\", 12)\n      .attr(\"fill\", \"#333\")\n      .attr(\"text-anchor\", \"start\")\n    .selectAll(\"text\")\n    .data(nodes)\n    .join(\"text\")\n      .text(({index: i}) =&gt; T ? T[i] : N[i])\n      .attr(\"dx\", nodeRadius + 3) // offset from node center\n      .attr(\"dy\", \"0.35em\") // vertical centering\n      .style(\"cursor\", LU ? \"pointer\" : null)\n      .call(drag(simulation))\n      .on(\"click\", function(event, d) {\n        if (LU && LU[d.index]) {\n          window.open(LU[d.index], '_blank');\n        }\n      });\n      \n  label.each(function(d) {\n    const bbox = this.getBBox();\n    const labelWidth = bbox.width;\n    const labelHeight = bbox.height;\n    // Extend collision radius to account for label\n    const baseRadius = R ? R[d.index] : nodeRadius;\n    d.collisionRadius = Math.max(baseRadius + 2, (labelWidth + nodeRadius + 6) / 2);\n  });\n      \n  if (W) link.attr(\"stroke-width\", ({index: i}) =&gt; W[i]);\n  if (L) link.attr(\"stroke\", ({index: i}) =&gt; L[i]);\n  if (G) node.attr(\"fill\", ({index: i}) =&gt; color(G[i]));\n  if (G) label.attr(\"fill\", ({index: i}) =&gt; color(G[i]));\n  if (R) node.attr(\"r\", ({index: i}) =&gt; R[i]);\n  if (T) node.append(\"title\").text(({index: i}) =&gt; T[i]);\n  if (invalidation != null) invalidation.then(() =&gt; simulation.stop());\n\n  function intern(value) {\n    return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n  }\n\n  function ticked() {\n    link\n      .attr(\"x1\", d =&gt; d.source.x)\n      .attr(\"y1\", d =&gt; d.source.y)\n      .attr(\"x2\", d =&gt; d.target.x)\n      .attr(\"y2\", d =&gt; d.target.y);\n\n//    node\n//      .attr(\"cx\", d =&gt; d.x)\n//      .attr(\"cy\", d =&gt; d.y);\n     node\n      .attr(\"cx\", d =&gt; {\n        const radius = d.collisionRadius || (R ? R[d.index] : nodeRadius);\n        return d.x = Math.max(radius - width/2, Math.min(width/2 - radius, d.x));\n      })\n      .attr(\"cy\", d =&gt; {\n        const radius = d.collisionRadius || (R ? R[d.index] : nodeRadius);\n        return d.y = Math.max(radius - height/2, Math.min(height/2 - radius, d.y));\n      });\n      \n    label\n      .attr(\"x\", d =&gt; d.x)\n      .attr(\"y\", d =&gt; d.y);\n  }\n\n  function drag(simulation) {    \n    function dragstarted(event) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }\n    \n    function dragged(event) {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }\n    \n    function dragended(event) {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }\n    \n    return d3.drag()\n      .on(\"start\", dragstarted)\n      .on(\"drag\", dragged)\n      .on(\"end\", dragended);\n  }\n\n  return Object.assign(svg.node(), {scales: {color}});\n}\n\n\n\n\n\n\n\nnt = transpose(nodes)\nlt = transpose(links)\ntt = transpose(themes)\nct = transpose(clusters)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilter articles by…\n\nviewof theme = Inputs.select(d3.group(tt, d =&gt; d.theme), {\n  label: \"Theme\",\n  //multiple: true,\n  value: \"All\"\n})\n\n\n\n\n\n\n\nviewof group = Inputs.select(d3.group(ct, d =&gt; d.group), {\n  label: \"Cluster\",\n  value: \"All\"\n})\n\n\n\n\n\n\n\n\nInclude links that are any of…\n\nviewof k = Inputs.range([1, 8], {\n  label: \"Each article's k closest neighbors\",\n  step: 1,\n  value: 2\n})\n\n\n\n\n\n\n\nviewof s = Inputs.range([0.9, 1], {\n  label: \"Edge weight at least\",\n  step: 0.01,\n  value: 0.95\n})\n\n\n\n\n\n\n\n\n\ntheme_ids = theme.map(d =&gt; d.id)\ngroup_ids = group.map(d =&gt; d.id)\n//theme_ids = theme.length ? theme.flat(1).map(d =&gt; d.id) : tt.map(d =&gt; d.id)\n\nltg = d3.groups(lt, d =&gt; d.source)\n  .flatMap(([source, values]) =&gt; \n    //values.sort((a, b) =&gt; b.value - a.value).slice(0, 2)\n    values\n      .sort((a, b) =&gt; b.value - a.value)\n      .filter((d, i) =&gt; i &lt; k || d.value &gt;= s)\n)\n\nltf = ltg.filter(d =&gt; theme_ids.includes(d.source)) // || theme_ids.includes(d.target))\n         .filter(d =&gt; theme_ids.includes(d.target))\n         .filter(d =&gt; group_ids.includes(d.source))\n         .filter(d =&gt; group_ids.includes(d.target))\n//        .filter(d =&gt; d.value &gt;= threshold)\nntf = nt.filter(d =&gt; theme_ids.includes(d.id))\n        .filter(d =&gt; group_ids.includes(d.id))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nForceGraph({nodes: ntf, links: ltf}, {\n  nodeGroup: d =&gt; d.group,\n  nodeTitle: d =&gt; d.id,\n  nodeLink: d =&gt; `https://oecs.mit.edu/pub/${d.slug}`,\n  linkStrokeWidth: l =&gt; l.value,\n  //linkStrokeWidth: l =&gt; Math.sqrt(l.value),\n  colors: d3.schemeCategory10,\n  repulsion: -100,\n  width: 1200,\n  height: 1000\n})"
  }
]